// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "hal_pb.proto" (package "hal_pb", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message hal_pb.Empty
 */
export interface Empty {
}
/**
 * @generated from protobuf message hal_pb.JointPosition
 */
export interface JointPosition {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: float position = 2;
     */
    position: number;
}
/**
 * @generated from protobuf message hal_pb.JointPositions
 */
export interface JointPositions {
    /**
     * @generated from protobuf field: repeated hal_pb.JointPosition positions = 1;
     */
    positions: JointPosition[];
}
/**
 * @generated from protobuf message hal_pb.WifiCredentials
 */
export interface WifiCredentials {
    /**
     * @generated from protobuf field: string ssid = 1;
     */
    ssid: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message hal_pb.ServoId
 */
export interface ServoId {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
}
/**
 * @generated from protobuf message hal_pb.ServoInfo
 */
export interface ServoInfo {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: float temperature = 2;
     */
    temperature: number;
    /**
     * @generated from protobuf field: float current = 3;
     */
    current: number;
    /**
     * @generated from protobuf field: float voltage = 4;
     */
    voltage: number;
    /**
     * @generated from protobuf field: float speed = 5;
     */
    speed: number;
    /**
     * @generated from protobuf field: float current_position = 6;
     */
    currentPosition: number;
    /**
     * @generated from protobuf field: float min_position = 7;
     */
    minPosition: number;
    /**
     * @generated from protobuf field: float max_position = 8;
     */
    maxPosition: number;
}
/**
 * @generated from protobuf message hal_pb.ServoInfoResponse
 */
export interface ServoInfoResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "info";
        /**
         * @generated from protobuf field: hal_pb.ServoInfo info = 1;
         */
        info: ServoInfo;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: hal_pb.ErrorInfo error = 2;
         */
        error: ErrorInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hal_pb.ChangeIdResponse
 */
export interface ChangeIdResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: bool success = 1;
         */
        success: boolean;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: hal_pb.ErrorInfo error = 2;
         */
        error: ErrorInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hal_pb.ErrorInfo
 */
export interface ErrorInfo {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message hal_pb.ServoIds
 */
export interface ServoIds {
    /**
     * @generated from protobuf field: repeated int32 ids = 1;
     */
    ids: number[];
}
/**
 * @generated from protobuf message hal_pb.IdChange
 */
export interface IdChange {
    /**
     * @generated from protobuf field: int32 old_id = 1;
     */
    oldId: number;
    /**
     * @generated from protobuf field: int32 new_id = 2;
     */
    newId: number;
}
/**
 * @generated from protobuf message hal_pb.VideoStreamUrls
 */
export interface VideoStreamUrls {
    /**
     * @generated from protobuf field: repeated string webrtc = 1;
     */
    webrtc: string[];
    /**
     * @generated from protobuf field: repeated string hls = 2;
     */
    hls: string[];
    /**
     * @generated from protobuf field: repeated string hls_ll = 3;
     */
    hlsLl: string[];
    /**
     * @generated from protobuf field: repeated string mse = 4;
     */
    mse: string[];
    /**
     * @generated from protobuf field: repeated string rtsp = 5;
     */
    rtsp: string[];
}
/**
 * @generated from protobuf message hal_pb.CalibrationResponse
 */
export interface CalibrationResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: bool success = 1;
         */
        success: boolean;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: hal_pb.ErrorInfo error = 2;
         */
        error: ErrorInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hal_pb.CalibrationStatus
 */
export interface CalibrationStatus {
    /**
     * @generated from protobuf field: bool is_calibrating = 1;
     */
    isCalibrating: boolean;
    /**
     * @generated from protobuf field: int32 calibrating_servo_id = 2;
     */
    calibratingServoId: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class Empty$Type extends MessageType<Empty> {
    constructor() {
        super("hal_pb.Empty", []);
    }
    create(value?: PartialMessage<Empty>): Empty {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Empty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Empty): Empty {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.Empty
 */
export const Empty = new Empty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JointPosition$Type extends MessageType<JointPosition> {
    constructor() {
        super("hal_pb.JointPosition", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<JointPosition>): JointPosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.position = 0;
        if (value !== undefined)
            reflectionMergePartial<JointPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JointPosition): JointPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* float position */ 2:
                    message.position = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JointPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* float position = 2; */
        if (message.position !== 0)
            writer.tag(2, WireType.Bit32).float(message.position);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.JointPosition
 */
export const JointPosition = new JointPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JointPositions$Type extends MessageType<JointPositions> {
    constructor() {
        super("hal_pb.JointPositions", [
            { no: 1, name: "positions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => JointPosition }
        ]);
    }
    create(value?: PartialMessage<JointPositions>): JointPositions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.positions = [];
        if (value !== undefined)
            reflectionMergePartial<JointPositions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JointPositions): JointPositions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hal_pb.JointPosition positions */ 1:
                    message.positions.push(JointPosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JointPositions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hal_pb.JointPosition positions = 1; */
        for (let i = 0; i < message.positions.length; i++)
            JointPosition.internalBinaryWrite(message.positions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.JointPositions
 */
export const JointPositions = new JointPositions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiCredentials$Type extends MessageType<WifiCredentials> {
    constructor() {
        super("hal_pb.WifiCredentials", [
            { no: 1, name: "ssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WifiCredentials>): WifiCredentials {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ssid = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<WifiCredentials>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiCredentials): WifiCredentials {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ssid */ 1:
                    message.ssid = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiCredentials, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ssid = 1; */
        if (message.ssid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ssid);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.WifiCredentials
 */
export const WifiCredentials = new WifiCredentials$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServoId$Type extends MessageType<ServoId> {
    constructor() {
        super("hal_pb.ServoId", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ServoId>): ServoId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<ServoId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServoId): ServoId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServoId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ServoId
 */
export const ServoId = new ServoId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServoInfo$Type extends MessageType<ServoInfo> {
    constructor() {
        super("hal_pb.ServoInfo", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "current", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "voltage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "current_position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "min_position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "max_position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ServoInfo>): ServoInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.temperature = 0;
        message.current = 0;
        message.voltage = 0;
        message.speed = 0;
        message.currentPosition = 0;
        message.minPosition = 0;
        message.maxPosition = 0;
        if (value !== undefined)
            reflectionMergePartial<ServoInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServoInfo): ServoInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* float temperature */ 2:
                    message.temperature = reader.float();
                    break;
                case /* float current */ 3:
                    message.current = reader.float();
                    break;
                case /* float voltage */ 4:
                    message.voltage = reader.float();
                    break;
                case /* float speed */ 5:
                    message.speed = reader.float();
                    break;
                case /* float current_position */ 6:
                    message.currentPosition = reader.float();
                    break;
                case /* float min_position */ 7:
                    message.minPosition = reader.float();
                    break;
                case /* float max_position */ 8:
                    message.maxPosition = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServoInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* float temperature = 2; */
        if (message.temperature !== 0)
            writer.tag(2, WireType.Bit32).float(message.temperature);
        /* float current = 3; */
        if (message.current !== 0)
            writer.tag(3, WireType.Bit32).float(message.current);
        /* float voltage = 4; */
        if (message.voltage !== 0)
            writer.tag(4, WireType.Bit32).float(message.voltage);
        /* float speed = 5; */
        if (message.speed !== 0)
            writer.tag(5, WireType.Bit32).float(message.speed);
        /* float current_position = 6; */
        if (message.currentPosition !== 0)
            writer.tag(6, WireType.Bit32).float(message.currentPosition);
        /* float min_position = 7; */
        if (message.minPosition !== 0)
            writer.tag(7, WireType.Bit32).float(message.minPosition);
        /* float max_position = 8; */
        if (message.maxPosition !== 0)
            writer.tag(8, WireType.Bit32).float(message.maxPosition);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ServoInfo
 */
export const ServoInfo = new ServoInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServoInfoResponse$Type extends MessageType<ServoInfoResponse> {
    constructor() {
        super("hal_pb.ServoInfoResponse", [
            { no: 1, name: "info", kind: "message", oneof: "result", T: () => ServoInfo },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => ErrorInfo }
        ]);
    }
    create(value?: PartialMessage<ServoInfoResponse>): ServoInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ServoInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServoInfoResponse): ServoInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hal_pb.ServoInfo info */ 1:
                    message.result = {
                        oneofKind: "info",
                        info: ServoInfo.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).info)
                    };
                    break;
                case /* hal_pb.ErrorInfo error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: ErrorInfo.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServoInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hal_pb.ServoInfo info = 1; */
        if (message.result.oneofKind === "info")
            ServoInfo.internalBinaryWrite(message.result.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* hal_pb.ErrorInfo error = 2; */
        if (message.result.oneofKind === "error")
            ErrorInfo.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ServoInfoResponse
 */
export const ServoInfoResponse = new ServoInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeIdResponse$Type extends MessageType<ChangeIdResponse> {
    constructor() {
        super("hal_pb.ChangeIdResponse", [
            { no: 1, name: "success", kind: "scalar", oneof: "result", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => ErrorInfo }
        ]);
    }
    create(value?: PartialMessage<ChangeIdResponse>): ChangeIdResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ChangeIdResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeIdResponse): ChangeIdResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.result = {
                        oneofKind: "success",
                        success: reader.bool()
                    };
                    break;
                case /* hal_pb.ErrorInfo error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: ErrorInfo.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeIdResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.result.oneofKind === "success")
            writer.tag(1, WireType.Varint).bool(message.result.success);
        /* hal_pb.ErrorInfo error = 2; */
        if (message.result.oneofKind === "error")
            ErrorInfo.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ChangeIdResponse
 */
export const ChangeIdResponse = new ChangeIdResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorInfo$Type extends MessageType<ErrorInfo> {
    constructor() {
        super("hal_pb.ErrorInfo", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ErrorInfo>): ErrorInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        message.code = 0;
        if (value !== undefined)
            reflectionMergePartial<ErrorInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorInfo): ErrorInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ErrorInfo
 */
export const ErrorInfo = new ErrorInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServoIds$Type extends MessageType<ServoIds> {
    constructor() {
        super("hal_pb.ServoIds", [
            { no: 1, name: "ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ServoIds>): ServoIds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ids = [];
        if (value !== undefined)
            reflectionMergePartial<ServoIds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServoIds): ServoIds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ids.push(reader.int32());
                    else
                        message.ids.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServoIds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 ids = 1; */
        if (message.ids.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ids.length; i++)
                writer.int32(message.ids[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ServoIds
 */
export const ServoIds = new ServoIds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdChange$Type extends MessageType<IdChange> {
    constructor() {
        super("hal_pb.IdChange", [
            { no: 1, name: "old_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "new_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<IdChange>): IdChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oldId = 0;
        message.newId = 0;
        if (value !== undefined)
            reflectionMergePartial<IdChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdChange): IdChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 old_id */ 1:
                    message.oldId = reader.int32();
                    break;
                case /* int32 new_id */ 2:
                    message.newId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IdChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 old_id = 1; */
        if (message.oldId !== 0)
            writer.tag(1, WireType.Varint).int32(message.oldId);
        /* int32 new_id = 2; */
        if (message.newId !== 0)
            writer.tag(2, WireType.Varint).int32(message.newId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.IdChange
 */
export const IdChange = new IdChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VideoStreamUrls$Type extends MessageType<VideoStreamUrls> {
    constructor() {
        super("hal_pb.VideoStreamUrls", [
            { no: 1, name: "webrtc", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hls", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hls_ll", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "mse", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "rtsp", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VideoStreamUrls>): VideoStreamUrls {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.webrtc = [];
        message.hls = [];
        message.hlsLl = [];
        message.mse = [];
        message.rtsp = [];
        if (value !== undefined)
            reflectionMergePartial<VideoStreamUrls>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VideoStreamUrls): VideoStreamUrls {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string webrtc */ 1:
                    message.webrtc.push(reader.string());
                    break;
                case /* repeated string hls */ 2:
                    message.hls.push(reader.string());
                    break;
                case /* repeated string hls_ll */ 3:
                    message.hlsLl.push(reader.string());
                    break;
                case /* repeated string mse */ 4:
                    message.mse.push(reader.string());
                    break;
                case /* repeated string rtsp */ 5:
                    message.rtsp.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VideoStreamUrls, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string webrtc = 1; */
        for (let i = 0; i < message.webrtc.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.webrtc[i]);
        /* repeated string hls = 2; */
        for (let i = 0; i < message.hls.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.hls[i]);
        /* repeated string hls_ll = 3; */
        for (let i = 0; i < message.hlsLl.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.hlsLl[i]);
        /* repeated string mse = 4; */
        for (let i = 0; i < message.mse.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.mse[i]);
        /* repeated string rtsp = 5; */
        for (let i = 0; i < message.rtsp.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.rtsp[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.VideoStreamUrls
 */
export const VideoStreamUrls = new VideoStreamUrls$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrationResponse$Type extends MessageType<CalibrationResponse> {
    constructor() {
        super("hal_pb.CalibrationResponse", [
            { no: 1, name: "success", kind: "scalar", oneof: "result", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => ErrorInfo }
        ]);
    }
    create(value?: PartialMessage<CalibrationResponse>): CalibrationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CalibrationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrationResponse): CalibrationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.result = {
                        oneofKind: "success",
                        success: reader.bool()
                    };
                    break;
                case /* hal_pb.ErrorInfo error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: ErrorInfo.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalibrationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.result.oneofKind === "success")
            writer.tag(1, WireType.Varint).bool(message.result.success);
        /* hal_pb.ErrorInfo error = 2; */
        if (message.result.oneofKind === "error")
            ErrorInfo.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.CalibrationResponse
 */
export const CalibrationResponse = new CalibrationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrationStatus$Type extends MessageType<CalibrationStatus> {
    constructor() {
        super("hal_pb.CalibrationStatus", [
            { no: 1, name: "is_calibrating", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "calibrating_servo_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CalibrationStatus>): CalibrationStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isCalibrating = false;
        message.calibratingServoId = 0;
        if (value !== undefined)
            reflectionMergePartial<CalibrationStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrationStatus): CalibrationStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_calibrating */ 1:
                    message.isCalibrating = reader.bool();
                    break;
                case /* int32 calibrating_servo_id */ 2:
                    message.calibratingServoId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalibrationStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_calibrating = 1; */
        if (message.isCalibrating !== false)
            writer.tag(1, WireType.Varint).bool(message.isCalibrating);
        /* int32 calibrating_servo_id = 2; */
        if (message.calibratingServoId !== 0)
            writer.tag(2, WireType.Varint).int32(message.calibratingServoId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.CalibrationStatus
 */
export const CalibrationStatus = new CalibrationStatus$Type();
/**
 * @generated ServiceType for protobuf service hal_pb.ServoControl
 */
export const ServoControl = new ServiceType("hal_pb.ServoControl", [
    { name: "GetPositions", options: {}, I: Empty, O: JointPositions },
    { name: "SetPositions", options: {}, I: JointPositions, O: Empty },
    { name: "SetWifiInfo", options: {}, I: WifiCredentials, O: Empty },
    { name: "GetServoInfo", options: {}, I: ServoId, O: ServoInfoResponse },
    { name: "Scan", options: {}, I: Empty, O: ServoIds },
    { name: "ChangeId", options: {}, I: IdChange, O: ChangeIdResponse },
    { name: "StartCalibration", options: {}, I: ServoId, O: CalibrationResponse },
    { name: "CancelCalibration", options: {}, I: ServoId, O: CalibrationResponse },
    { name: "StartVideoStream", options: {}, I: Empty, O: Empty },
    { name: "StopVideoStream", options: {}, I: Empty, O: Empty },
    { name: "GetVideoStreamUrls", options: {}, I: Empty, O: VideoStreamUrls },
    { name: "GetCalibrationStatus", options: {}, I: Empty, O: CalibrationStatus }
]);
