// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "hal_pb.proto" (package "hal_pb", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message hal_pb.Empty
 */
export interface Empty {
}
/**
 * @generated from protobuf message hal_pb.JointPosition
 */
export interface JointPosition {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: float position = 2;
     */
    position: number;
    /**
     * @generated from protobuf field: float speed = 3;
     */
    speed: number;
}
/**
 * @generated from protobuf message hal_pb.JointPositions
 */
export interface JointPositions {
    /**
     * @generated from protobuf field: repeated hal_pb.JointPosition positions = 1;
     */
    positions: JointPosition[];
}
/**
 * @generated from protobuf message hal_pb.WifiCredentials
 */
export interface WifiCredentials {
    /**
     * @generated from protobuf field: string ssid = 1;
     */
    ssid: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message hal_pb.ServoId
 */
export interface ServoId {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
}
/**
 * @generated from protobuf message hal_pb.ServoInfo
 */
export interface ServoInfo {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: float temperature = 2;
     */
    temperature: number;
    /**
     * @generated from protobuf field: float current = 3;
     */
    current: number;
    /**
     * @generated from protobuf field: float voltage = 4;
     */
    voltage: number;
    /**
     * @generated from protobuf field: float speed = 5;
     */
    speed: number;
    /**
     * @generated from protobuf field: float current_position = 6;
     */
    currentPosition: number;
    /**
     * @generated from protobuf field: float min_position = 7;
     */
    minPosition: number;
    /**
     * @generated from protobuf field: float max_position = 8;
     */
    maxPosition: number;
}
/**
 * @generated from protobuf message hal_pb.ServoInfoResponse
 */
export interface ServoInfoResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "info";
        /**
         * @generated from protobuf field: hal_pb.ServoInfo info = 1;
         */
        info: ServoInfo;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: hal_pb.ErrorInfo error = 2;
         */
        error: ErrorInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hal_pb.ChangeIdResponse
 */
export interface ChangeIdResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: bool success = 1;
         */
        success: boolean;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: hal_pb.ErrorInfo error = 2;
         */
        error: ErrorInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hal_pb.ErrorInfo
 */
export interface ErrorInfo {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message hal_pb.ServoIds
 */
export interface ServoIds {
    /**
     * @generated from protobuf field: repeated int32 ids = 1;
     */
    ids: number[];
}
/**
 * @generated from protobuf message hal_pb.IdChange
 */
export interface IdChange {
    /**
     * @generated from protobuf field: int32 old_id = 1;
     */
    oldId: number;
    /**
     * @generated from protobuf field: int32 new_id = 2;
     */
    newId: number;
}
/**
 * @generated from protobuf message hal_pb.VideoStreamUrls
 */
export interface VideoStreamUrls {
    /**
     * @generated from protobuf field: repeated string webrtc = 1;
     */
    webrtc: string[];
    /**
     * @generated from protobuf field: repeated string hls = 2;
     */
    hls: string[];
    /**
     * @generated from protobuf field: repeated string hls_ll = 3;
     */
    hlsLl: string[];
    /**
     * @generated from protobuf field: repeated string mse = 4;
     */
    mse: string[];
    /**
     * @generated from protobuf field: repeated string rtsp = 5;
     */
    rtsp: string[];
}
/**
 * @generated from protobuf message hal_pb.CalibrationResponse
 */
export interface CalibrationResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: bool success = 1;
         */
        success: boolean;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: hal_pb.ErrorInfo error = 2;
         */
        error: ErrorInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hal_pb.CalibrationStatus
 */
export interface CalibrationStatus {
    /**
     * @generated from protobuf field: bool is_calibrating = 1;
     */
    isCalibrating: boolean;
    /**
     * @generated from protobuf field: int32 calibrating_servo_id = 2;
     */
    calibratingServoId: number;
}
/**
 * @generated from protobuf message hal_pb.TorqueSettings
 */
export interface TorqueSettings {
    /**
     * @generated from protobuf field: repeated hal_pb.TorqueSetting settings = 1;
     */
    settings: TorqueSetting[];
}
/**
 * @generated from protobuf message hal_pb.TorqueSetting
 */
export interface TorqueSetting {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: float torque = 2;
     */
    torque: number;
}
/**
 * @generated from protobuf message hal_pb.TorqueEnableSettings
 */
export interface TorqueEnableSettings {
    /**
     * @generated from protobuf field: repeated hal_pb.TorqueEnableSetting settings = 1;
     */
    settings: TorqueEnableSetting[];
}
/**
 * @generated from protobuf message hal_pb.TorqueEnableSetting
 */
export interface TorqueEnableSetting {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: bool enable = 2;
     */
    enable: boolean;
}
/**
 * @generated from protobuf message hal_pb.ImuData
 */
export interface ImuData {
    /**
     * @generated from protobuf field: hal_pb.Vector3 gyro = 1;
     */
    gyro?: Vector3; // Angular velocity in degrees per second (dps)
    /**
     * @generated from protobuf field: hal_pb.Vector3 accel = 2;
     */
    accel?: Vector3; // Linear acceleration in milli-g (mg)
}
/**
 * @generated from protobuf message hal_pb.Vector3
 */
export interface Vector3 {
    /**
     * @generated from protobuf field: float x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 3;
     */
    z: number;
}
/**
 * @generated from protobuf message hal_pb.AudioChunk
 */
export interface AudioChunk {
    /**
     * @generated from protobuf field: bytes data = 1;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string format = 2;
     */
    format: string; // e.g., "wav", "mp3"
    /**
     * @generated from protobuf field: int64 timestamp = 3;
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message hal_pb.UploadResponse
 */
export interface UploadResponse {
    /**
     * @generated from protobuf field: string audio_id = 1;
     */
    audioId: string;
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: bool success = 2;
         */
        success: boolean;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: hal_pb.ErrorInfo error = 3;
         */
        error: ErrorInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hal_pb.PlayRequest
 */
export interface PlayRequest {
    /**
     * @generated from protobuf field: string audio_id = 1;
     */
    audioId: string;
    /**
     * @generated from protobuf field: float volume = 2;
     */
    volume: number; // 0.0 to 1.0
}
/**
 * @generated from protobuf message hal_pb.RecordingConfig
 */
export interface RecordingConfig {
    /**
     * @generated from protobuf field: int32 sample_rate = 1;
     */
    sampleRate: number; // e.g., 44100, 48000
    /**
     * @generated from protobuf field: string format = 2;
     */
    format: string; // e.g., "wav"
    /**
     * @generated from protobuf field: int32 channels = 3;
     */
    channels: number; // e.g., 1 for mono, 2 for stereo
}
/**
 * @generated from protobuf message hal_pb.CalibrationRequest
 */
export interface CalibrationRequest {
    /**
     * @generated from protobuf field: int32 servo_id = 1;
     */
    servoId: number;
    /**
     * @generated from protobuf field: int32 calibration_speed = 2;
     */
    calibrationSpeed: number;
    /**
     * @generated from protobuf field: float current_threshold = 3;
     */
    currentThreshold: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class Empty$Type extends MessageType<Empty> {
    constructor() {
        super("hal_pb.Empty", []);
    }
    create(value?: PartialMessage<Empty>): Empty {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Empty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Empty): Empty {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.Empty
 */
export const Empty = new Empty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JointPosition$Type extends MessageType<JointPosition> {
    constructor() {
        super("hal_pb.JointPosition", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<JointPosition>): JointPosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.position = 0;
        message.speed = 0;
        if (value !== undefined)
            reflectionMergePartial<JointPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JointPosition): JointPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* float position */ 2:
                    message.position = reader.float();
                    break;
                case /* float speed */ 3:
                    message.speed = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JointPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* float position = 2; */
        if (message.position !== 0)
            writer.tag(2, WireType.Bit32).float(message.position);
        /* float speed = 3; */
        if (message.speed !== 0)
            writer.tag(3, WireType.Bit32).float(message.speed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.JointPosition
 */
export const JointPosition = new JointPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JointPositions$Type extends MessageType<JointPositions> {
    constructor() {
        super("hal_pb.JointPositions", [
            { no: 1, name: "positions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => JointPosition }
        ]);
    }
    create(value?: PartialMessage<JointPositions>): JointPositions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.positions = [];
        if (value !== undefined)
            reflectionMergePartial<JointPositions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JointPositions): JointPositions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hal_pb.JointPosition positions */ 1:
                    message.positions.push(JointPosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JointPositions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hal_pb.JointPosition positions = 1; */
        for (let i = 0; i < message.positions.length; i++)
            JointPosition.internalBinaryWrite(message.positions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.JointPositions
 */
export const JointPositions = new JointPositions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiCredentials$Type extends MessageType<WifiCredentials> {
    constructor() {
        super("hal_pb.WifiCredentials", [
            { no: 1, name: "ssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WifiCredentials>): WifiCredentials {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ssid = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<WifiCredentials>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiCredentials): WifiCredentials {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ssid */ 1:
                    message.ssid = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiCredentials, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ssid = 1; */
        if (message.ssid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ssid);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.WifiCredentials
 */
export const WifiCredentials = new WifiCredentials$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServoId$Type extends MessageType<ServoId> {
    constructor() {
        super("hal_pb.ServoId", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ServoId>): ServoId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<ServoId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServoId): ServoId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServoId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ServoId
 */
export const ServoId = new ServoId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServoInfo$Type extends MessageType<ServoInfo> {
    constructor() {
        super("hal_pb.ServoInfo", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "current", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "voltage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "current_position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "min_position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "max_position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ServoInfo>): ServoInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.temperature = 0;
        message.current = 0;
        message.voltage = 0;
        message.speed = 0;
        message.currentPosition = 0;
        message.minPosition = 0;
        message.maxPosition = 0;
        if (value !== undefined)
            reflectionMergePartial<ServoInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServoInfo): ServoInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* float temperature */ 2:
                    message.temperature = reader.float();
                    break;
                case /* float current */ 3:
                    message.current = reader.float();
                    break;
                case /* float voltage */ 4:
                    message.voltage = reader.float();
                    break;
                case /* float speed */ 5:
                    message.speed = reader.float();
                    break;
                case /* float current_position */ 6:
                    message.currentPosition = reader.float();
                    break;
                case /* float min_position */ 7:
                    message.minPosition = reader.float();
                    break;
                case /* float max_position */ 8:
                    message.maxPosition = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServoInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* float temperature = 2; */
        if (message.temperature !== 0)
            writer.tag(2, WireType.Bit32).float(message.temperature);
        /* float current = 3; */
        if (message.current !== 0)
            writer.tag(3, WireType.Bit32).float(message.current);
        /* float voltage = 4; */
        if (message.voltage !== 0)
            writer.tag(4, WireType.Bit32).float(message.voltage);
        /* float speed = 5; */
        if (message.speed !== 0)
            writer.tag(5, WireType.Bit32).float(message.speed);
        /* float current_position = 6; */
        if (message.currentPosition !== 0)
            writer.tag(6, WireType.Bit32).float(message.currentPosition);
        /* float min_position = 7; */
        if (message.minPosition !== 0)
            writer.tag(7, WireType.Bit32).float(message.minPosition);
        /* float max_position = 8; */
        if (message.maxPosition !== 0)
            writer.tag(8, WireType.Bit32).float(message.maxPosition);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ServoInfo
 */
export const ServoInfo = new ServoInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServoInfoResponse$Type extends MessageType<ServoInfoResponse> {
    constructor() {
        super("hal_pb.ServoInfoResponse", [
            { no: 1, name: "info", kind: "message", oneof: "result", T: () => ServoInfo },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => ErrorInfo }
        ]);
    }
    create(value?: PartialMessage<ServoInfoResponse>): ServoInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ServoInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServoInfoResponse): ServoInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hal_pb.ServoInfo info */ 1:
                    message.result = {
                        oneofKind: "info",
                        info: ServoInfo.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).info)
                    };
                    break;
                case /* hal_pb.ErrorInfo error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: ErrorInfo.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServoInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hal_pb.ServoInfo info = 1; */
        if (message.result.oneofKind === "info")
            ServoInfo.internalBinaryWrite(message.result.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* hal_pb.ErrorInfo error = 2; */
        if (message.result.oneofKind === "error")
            ErrorInfo.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ServoInfoResponse
 */
export const ServoInfoResponse = new ServoInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeIdResponse$Type extends MessageType<ChangeIdResponse> {
    constructor() {
        super("hal_pb.ChangeIdResponse", [
            { no: 1, name: "success", kind: "scalar", oneof: "result", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => ErrorInfo }
        ]);
    }
    create(value?: PartialMessage<ChangeIdResponse>): ChangeIdResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ChangeIdResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeIdResponse): ChangeIdResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.result = {
                        oneofKind: "success",
                        success: reader.bool()
                    };
                    break;
                case /* hal_pb.ErrorInfo error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: ErrorInfo.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeIdResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.result.oneofKind === "success")
            writer.tag(1, WireType.Varint).bool(message.result.success);
        /* hal_pb.ErrorInfo error = 2; */
        if (message.result.oneofKind === "error")
            ErrorInfo.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ChangeIdResponse
 */
export const ChangeIdResponse = new ChangeIdResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorInfo$Type extends MessageType<ErrorInfo> {
    constructor() {
        super("hal_pb.ErrorInfo", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ErrorInfo>): ErrorInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        message.code = 0;
        if (value !== undefined)
            reflectionMergePartial<ErrorInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorInfo): ErrorInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ErrorInfo
 */
export const ErrorInfo = new ErrorInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServoIds$Type extends MessageType<ServoIds> {
    constructor() {
        super("hal_pb.ServoIds", [
            { no: 1, name: "ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ServoIds>): ServoIds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ids = [];
        if (value !== undefined)
            reflectionMergePartial<ServoIds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServoIds): ServoIds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ids.push(reader.int32());
                    else
                        message.ids.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServoIds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 ids = 1; */
        if (message.ids.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ids.length; i++)
                writer.int32(message.ids[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ServoIds
 */
export const ServoIds = new ServoIds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdChange$Type extends MessageType<IdChange> {
    constructor() {
        super("hal_pb.IdChange", [
            { no: 1, name: "old_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "new_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<IdChange>): IdChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oldId = 0;
        message.newId = 0;
        if (value !== undefined)
            reflectionMergePartial<IdChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdChange): IdChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 old_id */ 1:
                    message.oldId = reader.int32();
                    break;
                case /* int32 new_id */ 2:
                    message.newId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IdChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 old_id = 1; */
        if (message.oldId !== 0)
            writer.tag(1, WireType.Varint).int32(message.oldId);
        /* int32 new_id = 2; */
        if (message.newId !== 0)
            writer.tag(2, WireType.Varint).int32(message.newId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.IdChange
 */
export const IdChange = new IdChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VideoStreamUrls$Type extends MessageType<VideoStreamUrls> {
    constructor() {
        super("hal_pb.VideoStreamUrls", [
            { no: 1, name: "webrtc", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hls", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hls_ll", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "mse", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "rtsp", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VideoStreamUrls>): VideoStreamUrls {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.webrtc = [];
        message.hls = [];
        message.hlsLl = [];
        message.mse = [];
        message.rtsp = [];
        if (value !== undefined)
            reflectionMergePartial<VideoStreamUrls>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VideoStreamUrls): VideoStreamUrls {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string webrtc */ 1:
                    message.webrtc.push(reader.string());
                    break;
                case /* repeated string hls */ 2:
                    message.hls.push(reader.string());
                    break;
                case /* repeated string hls_ll */ 3:
                    message.hlsLl.push(reader.string());
                    break;
                case /* repeated string mse */ 4:
                    message.mse.push(reader.string());
                    break;
                case /* repeated string rtsp */ 5:
                    message.rtsp.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VideoStreamUrls, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string webrtc = 1; */
        for (let i = 0; i < message.webrtc.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.webrtc[i]);
        /* repeated string hls = 2; */
        for (let i = 0; i < message.hls.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.hls[i]);
        /* repeated string hls_ll = 3; */
        for (let i = 0; i < message.hlsLl.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.hlsLl[i]);
        /* repeated string mse = 4; */
        for (let i = 0; i < message.mse.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.mse[i]);
        /* repeated string rtsp = 5; */
        for (let i = 0; i < message.rtsp.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.rtsp[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.VideoStreamUrls
 */
export const VideoStreamUrls = new VideoStreamUrls$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrationResponse$Type extends MessageType<CalibrationResponse> {
    constructor() {
        super("hal_pb.CalibrationResponse", [
            { no: 1, name: "success", kind: "scalar", oneof: "result", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => ErrorInfo }
        ]);
    }
    create(value?: PartialMessage<CalibrationResponse>): CalibrationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CalibrationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrationResponse): CalibrationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.result = {
                        oneofKind: "success",
                        success: reader.bool()
                    };
                    break;
                case /* hal_pb.ErrorInfo error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: ErrorInfo.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalibrationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.result.oneofKind === "success")
            writer.tag(1, WireType.Varint).bool(message.result.success);
        /* hal_pb.ErrorInfo error = 2; */
        if (message.result.oneofKind === "error")
            ErrorInfo.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.CalibrationResponse
 */
export const CalibrationResponse = new CalibrationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrationStatus$Type extends MessageType<CalibrationStatus> {
    constructor() {
        super("hal_pb.CalibrationStatus", [
            { no: 1, name: "is_calibrating", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "calibrating_servo_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CalibrationStatus>): CalibrationStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isCalibrating = false;
        message.calibratingServoId = 0;
        if (value !== undefined)
            reflectionMergePartial<CalibrationStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrationStatus): CalibrationStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_calibrating */ 1:
                    message.isCalibrating = reader.bool();
                    break;
                case /* int32 calibrating_servo_id */ 2:
                    message.calibratingServoId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalibrationStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_calibrating = 1; */
        if (message.isCalibrating !== false)
            writer.tag(1, WireType.Varint).bool(message.isCalibrating);
        /* int32 calibrating_servo_id = 2; */
        if (message.calibratingServoId !== 0)
            writer.tag(2, WireType.Varint).int32(message.calibratingServoId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.CalibrationStatus
 */
export const CalibrationStatus = new CalibrationStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TorqueSettings$Type extends MessageType<TorqueSettings> {
    constructor() {
        super("hal_pb.TorqueSettings", [
            { no: 1, name: "settings", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TorqueSetting }
        ]);
    }
    create(value?: PartialMessage<TorqueSettings>): TorqueSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.settings = [];
        if (value !== undefined)
            reflectionMergePartial<TorqueSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TorqueSettings): TorqueSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hal_pb.TorqueSetting settings */ 1:
                    message.settings.push(TorqueSetting.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TorqueSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hal_pb.TorqueSetting settings = 1; */
        for (let i = 0; i < message.settings.length; i++)
            TorqueSetting.internalBinaryWrite(message.settings[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.TorqueSettings
 */
export const TorqueSettings = new TorqueSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TorqueSetting$Type extends MessageType<TorqueSetting> {
    constructor() {
        super("hal_pb.TorqueSetting", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "torque", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<TorqueSetting>): TorqueSetting {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.torque = 0;
        if (value !== undefined)
            reflectionMergePartial<TorqueSetting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TorqueSetting): TorqueSetting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* float torque */ 2:
                    message.torque = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TorqueSetting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* float torque = 2; */
        if (message.torque !== 0)
            writer.tag(2, WireType.Bit32).float(message.torque);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.TorqueSetting
 */
export const TorqueSetting = new TorqueSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TorqueEnableSettings$Type extends MessageType<TorqueEnableSettings> {
    constructor() {
        super("hal_pb.TorqueEnableSettings", [
            { no: 1, name: "settings", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TorqueEnableSetting }
        ]);
    }
    create(value?: PartialMessage<TorqueEnableSettings>): TorqueEnableSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.settings = [];
        if (value !== undefined)
            reflectionMergePartial<TorqueEnableSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TorqueEnableSettings): TorqueEnableSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hal_pb.TorqueEnableSetting settings */ 1:
                    message.settings.push(TorqueEnableSetting.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TorqueEnableSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hal_pb.TorqueEnableSetting settings = 1; */
        for (let i = 0; i < message.settings.length; i++)
            TorqueEnableSetting.internalBinaryWrite(message.settings[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.TorqueEnableSettings
 */
export const TorqueEnableSettings = new TorqueEnableSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TorqueEnableSetting$Type extends MessageType<TorqueEnableSetting> {
    constructor() {
        super("hal_pb.TorqueEnableSetting", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "enable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TorqueEnableSetting>): TorqueEnableSetting {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.enable = false;
        if (value !== undefined)
            reflectionMergePartial<TorqueEnableSetting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TorqueEnableSetting): TorqueEnableSetting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* bool enable */ 2:
                    message.enable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TorqueEnableSetting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* bool enable = 2; */
        if (message.enable !== false)
            writer.tag(2, WireType.Varint).bool(message.enable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.TorqueEnableSetting
 */
export const TorqueEnableSetting = new TorqueEnableSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImuData$Type extends MessageType<ImuData> {
    constructor() {
        super("hal_pb.ImuData", [
            { no: 1, name: "gyro", kind: "message", T: () => Vector3 },
            { no: 2, name: "accel", kind: "message", T: () => Vector3 }
        ]);
    }
    create(value?: PartialMessage<ImuData>): ImuData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ImuData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImuData): ImuData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hal_pb.Vector3 gyro */ 1:
                    message.gyro = Vector3.internalBinaryRead(reader, reader.uint32(), options, message.gyro);
                    break;
                case /* hal_pb.Vector3 accel */ 2:
                    message.accel = Vector3.internalBinaryRead(reader, reader.uint32(), options, message.accel);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImuData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hal_pb.Vector3 gyro = 1; */
        if (message.gyro)
            Vector3.internalBinaryWrite(message.gyro, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* hal_pb.Vector3 accel = 2; */
        if (message.accel)
            Vector3.internalBinaryWrite(message.accel, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.ImuData
 */
export const ImuData = new ImuData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vector3$Type extends MessageType<Vector3> {
    constructor() {
        super("hal_pb.Vector3", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Vector3>): Vector3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<Vector3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector3): Vector3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.Vector3
 */
export const Vector3 = new Vector3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AudioChunk$Type extends MessageType<AudioChunk> {
    constructor() {
        super("hal_pb.AudioChunk", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AudioChunk>): AudioChunk {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        message.format = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<AudioChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AudioChunk): AudioChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* string format */ 2:
                    message.format = reader.string();
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AudioChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* string format = 2; */
        if (message.format !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.format);
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.AudioChunk
 */
export const AudioChunk = new AudioChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadResponse$Type extends MessageType<UploadResponse> {
    constructor() {
        super("hal_pb.UploadResponse", [
            { no: 1, name: "audio_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "success", kind: "scalar", oneof: "result", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", oneof: "result", T: () => ErrorInfo }
        ]);
    }
    create(value?: PartialMessage<UploadResponse>): UploadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.audioId = "";
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<UploadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadResponse): UploadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string audio_id */ 1:
                    message.audioId = reader.string();
                    break;
                case /* bool success */ 2:
                    message.result = {
                        oneofKind: "success",
                        success: reader.bool()
                    };
                    break;
                case /* hal_pb.ErrorInfo error */ 3:
                    message.result = {
                        oneofKind: "error",
                        error: ErrorInfo.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string audio_id = 1; */
        if (message.audioId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.audioId);
        /* bool success = 2; */
        if (message.result.oneofKind === "success")
            writer.tag(2, WireType.Varint).bool(message.result.success);
        /* hal_pb.ErrorInfo error = 3; */
        if (message.result.oneofKind === "error")
            ErrorInfo.internalBinaryWrite(message.result.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.UploadResponse
 */
export const UploadResponse = new UploadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayRequest$Type extends MessageType<PlayRequest> {
    constructor() {
        super("hal_pb.PlayRequest", [
            { no: 1, name: "audio_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<PlayRequest>): PlayRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.audioId = "";
        message.volume = 0;
        if (value !== undefined)
            reflectionMergePartial<PlayRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayRequest): PlayRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string audio_id */ 1:
                    message.audioId = reader.string();
                    break;
                case /* float volume */ 2:
                    message.volume = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string audio_id = 1; */
        if (message.audioId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.audioId);
        /* float volume = 2; */
        if (message.volume !== 0)
            writer.tag(2, WireType.Bit32).float(message.volume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.PlayRequest
 */
export const PlayRequest = new PlayRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingConfig$Type extends MessageType<RecordingConfig> {
    constructor() {
        super("hal_pb.RecordingConfig", [
            { no: 1, name: "sample_rate", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "channels", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RecordingConfig>): RecordingConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sampleRate = 0;
        message.format = "";
        message.channels = 0;
        if (value !== undefined)
            reflectionMergePartial<RecordingConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordingConfig): RecordingConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 sample_rate */ 1:
                    message.sampleRate = reader.int32();
                    break;
                case /* string format */ 2:
                    message.format = reader.string();
                    break;
                case /* int32 channels */ 3:
                    message.channels = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordingConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 sample_rate = 1; */
        if (message.sampleRate !== 0)
            writer.tag(1, WireType.Varint).int32(message.sampleRate);
        /* string format = 2; */
        if (message.format !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.format);
        /* int32 channels = 3; */
        if (message.channels !== 0)
            writer.tag(3, WireType.Varint).int32(message.channels);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.RecordingConfig
 */
export const RecordingConfig = new RecordingConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrationRequest$Type extends MessageType<CalibrationRequest> {
    constructor() {
        super("hal_pb.CalibrationRequest", [
            { no: 1, name: "servo_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "calibration_speed", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "current_threshold", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CalibrationRequest>): CalibrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.servoId = 0;
        message.calibrationSpeed = 0;
        message.currentThreshold = 0;
        if (value !== undefined)
            reflectionMergePartial<CalibrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrationRequest): CalibrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 servo_id */ 1:
                    message.servoId = reader.int32();
                    break;
                case /* int32 calibration_speed */ 2:
                    message.calibrationSpeed = reader.int32();
                    break;
                case /* float current_threshold */ 3:
                    message.currentThreshold = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalibrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 servo_id = 1; */
        if (message.servoId !== 0)
            writer.tag(1, WireType.Varint).int32(message.servoId);
        /* int32 calibration_speed = 2; */
        if (message.calibrationSpeed !== 0)
            writer.tag(2, WireType.Varint).int32(message.calibrationSpeed);
        /* float current_threshold = 3; */
        if (message.currentThreshold !== 0)
            writer.tag(3, WireType.Bit32).float(message.currentThreshold);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hal_pb.CalibrationRequest
 */
export const CalibrationRequest = new CalibrationRequest$Type();
/**
 * @generated ServiceType for protobuf service hal_pb.ServoControl
 */
export const ServoControl = new ServiceType("hal_pb.ServoControl", [
    { name: "GetPositions", options: {}, I: Empty, O: JointPositions },
    { name: "SetPositions", options: {}, I: JointPositions, O: Empty },
    { name: "EnableMovement", options: {}, I: Empty, O: Empty },
    { name: "DisableMovement", options: {}, I: Empty, O: Empty },
    { name: "SetPosition", options: {}, I: JointPosition, O: Empty },
    { name: "SetWifiInfo", options: {}, I: WifiCredentials, O: Empty },
    { name: "GetServoInfo", options: {}, I: ServoId, O: ServoInfoResponse },
    { name: "Scan", options: {}, I: Empty, O: ServoIds },
    { name: "ChangeId", options: {}, I: IdChange, O: ChangeIdResponse },
    { name: "StartCalibration", options: {}, I: CalibrationRequest, O: CalibrationResponse },
    { name: "CancelCalibration", options: {}, I: ServoId, O: CalibrationResponse },
    { name: "StartVideoStream", options: {}, I: Empty, O: Empty },
    { name: "StopVideoStream", options: {}, I: Empty, O: Empty },
    { name: "GetVideoStreamUrls", options: {}, I: Empty, O: VideoStreamUrls },
    { name: "GetCalibrationStatus", options: {}, I: Empty, O: CalibrationStatus },
    { name: "SetTorque", options: {}, I: TorqueSettings, O: Empty },
    { name: "SetTorqueEnable", options: {}, I: TorqueEnableSettings, O: Empty },
    { name: "GetImuData", options: {}, I: Empty, O: ImuData },
    { name: "UploadAudio", clientStreaming: true, options: {}, I: AudioChunk, O: UploadResponse },
    { name: "PlayAudio", options: {}, I: PlayRequest, O: Empty },
    { name: "StartRecording", options: {}, I: RecordingConfig, O: Empty },
    { name: "StopRecording", options: {}, I: Empty, O: Empty },
    { name: "GetRecordedAudio", serverStreaming: true, options: {}, I: Empty, O: AudioChunk }
]);
